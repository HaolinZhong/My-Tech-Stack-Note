# DP

## DP的整体框架

- 状态转移方程
- 重叠子问题
  - 解决方法: 备忘录
  - 备忘录可尝试优化到constant space



## 最长递增子序列 (longest increasing sub seq)

- 状态转移方程: 
  - dp(i): 以 $i_{th}$ element为最后一位的LISS的长度
  - $dp(i) = max\{dp(j) + 1 \mid j \in [0, i) \cap N, a_j < a_i  \} $, dp(0) = 1  
  - $O(n^2)$
- patience sort
  - 逐个取元素按规则组成数个"牌堆"
    - 只有某个堆顶部元素大于当前元素时, 才能将元素放入该堆
      - 若有多个满足条件的堆, 放置在最左侧
      - 若不存在满足条件的堆, 则用当前元素开一个新的堆
    - 完成后, **牌堆的数量就是LISS的数量**
    - 选择堆的方法: 二分搜索即可, 因此放一次牌可认为是$O(logn)$, 总复杂度为$O(nlogn)$



- Russian Envelope (Hard)
  - 给定一系列长宽为`[x, y]`的信封. 问信封最多能套几层? (`x1 < x2, y1 < y2`时, 认为`[x1, y1]`能套在`[x2, y2]`里)
  - 排序: **按x升序, 再按y降序**, 然后只看y值, 将问题转换为LIS
    - x升序: 保证x维度不是问题, 使其可被忽略
    - y降序: 保证x相同的信封不能够算作可套





 ## 子序列

### 编辑距离

- 给定两字符串, 问最少需要几步操作使得两字符串相同?
- 解法
  - 定义操作类型: 删除, 替换, 插入
  - 定义状态:  i指针 (位于s1上) , j指针(位于s2上)  -> 最少操作数
  - 状态转移方程:
    - $dp(i, j) = \min \{ dp(i+1, j) + 1, \space dp(i+1, j+1) + 1, \space dp(i, j+1) + 1\}$    
    - `dp(i+1, j)`: 删除, 因为i位置字符被删掉, 所以i直接往后移1位
    - `dp(i+1, j+1)`: 替换, 因为替换保证能匹配上, 所以两个指针都可以后移了
    - `dp(i, j+1)`: 插入, 因为插入保证能匹配上, 所以j指针后移, 但i指针指向的字符没有被移除, 还会继续比对, 所以i不移动
    - 当然, 如果i, j指向的字符本来就相等, 就不需要用到方程了
    - base case: 
      - `dp(m, n) = 0`, m和n为两字符串长度, 两个都走完时不用操作
      - `dp(m, j) = n - j, dp(i, n) = m - i`, 一个走完时把另一个剩下的全部插入



### 最大子数组

- 子序列不要求元素在原本数组中连续, 子数组则要求连续
- 解法
  - 定义状态: dp(i): 以i号元素结尾的子数组的最大值
  - 状态转移方程: $dp(i) = \max \{dp(i-1) + a_i, \space a_i  \}$



